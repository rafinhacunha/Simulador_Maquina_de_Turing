#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "cJSON.h"   

#define MAX_FITA 10000
#define MAX_TRANSICOES 1000

typedef struct {
    int from;
    int to;
    char read;
    char write;
    char dir; // 'R' ou 'L'
} Transicao;

typedef struct {
    int initial;
    int finais[100];
    int num_finais;
    char branco;
    Transicao transicoes[MAX_TRANSICOES];
    int num_transicoes;
} MaquinaTuring;

void carregar_maquina(const char *arquivo, MaquinaTuring *mt) {
    FILE *f = fopen(arquivo, "r");
    if (!f) {
        perror("Erro abrindo JSON");
        exit(1);
    }

    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    fseek(f, 0, SEEK_SET);
    char *data = malloc(len + 1);
    fread(data, 1, len, f);
    fclose(f);
    data[len] = '\0';

    cJSON *json = cJSON_Parse(data);
    if (!json) {
        printf("Erro parseando JSON\n");
        exit(1);
    }

    mt->initial = cJSON_GetObjectItem(json, "initial")->valueint;
    mt->branco = cJSON_GetObjectItem(json, "white")->valuestring[0];

    cJSON *finais = cJSON_GetObjectItem(json, "final");
    mt->num_finais = cJSON_GetArraySize(finais);
    for (int i = 0; i < mt->num_finais; i++) {
        mt->finais[i] = cJSON_GetArrayItem(finais, i)->valueint;
    }

    cJSON *trans = cJSON_GetObjectItem(json, "transitions");
    mt->num_transicoes = cJSON_GetArraySize(trans);
    for (int i = 0; i < mt->num_transicoes; i++) {
        cJSON *t = cJSON_GetArrayItem(trans, i);
        mt->transicoes[i].from = cJSON_GetObjectItem(t, "from")->valueint;
        mt->transicoes[i].to   = cJSON_GetObjectItem(t, "to")->valueint;
        mt->transicoes[i].read = cJSON_GetObjectItem(t, "read")->valuestring[0];
        mt->transicoes[i].write= cJSON_GetObjectItem(t, "write")->valuestring[0];
        mt->transicoes[i].dir  = cJSON_GetObjectItem(t, "dir")->valuestring[0];
    }

    cJSON_Delete(json);
    free(data);
}

void carregar_fita(const char *arquivo, char *fita) {
    FILE *f = fopen(arquivo, "r");
    if (!f) {
        perror("Erro abrindo entrada");
        exit(1);
    }
    fgets(fita, MAX_FITA, f);
    fita[strcspn(fita, "\n")] = 0; // remove \n
    fclose(f);
}

void salvar_fita(const char *arquivo, char *fita) {
    FILE *f = fopen(arquivo, "w");
    if (!f) {
        perror("Erro salvando saída");
        exit(1);
    }
    fprintf(f, "%s", fita);
    fclose(f);
}

int simular(MaquinaTuring *mt, char *fita) {
    int estado = mt->initial;
    int cabeca = 0;

    // Expande fita com branco
    int len = strlen(fita);
    for (int i = len; i < MAX_FITA; i++) fita[i] = mt->branco;
    fita[MAX_FITA - 1] = '\0';

    while (1) {
        char simbolo = fita[cabeca];
        Transicao *trans = NULL;

        for (int i = 0; i < mt->num_transicoes; i++) {
            if (mt->transicoes[i].from == estado && mt->transicoes[i].read == simbolo) {
                trans = &mt->transicoes[i];
                break;
            }
        }

        if (!trans) {
            // verifica aceitação
            for (int i = 0; i < mt->num_finais; i++) {
                if (estado == mt->finais[i]) return 1; // aceita
            }
            return 0; // rejeita
        }

        fita[cabeca] = trans->write;
        estado = trans->to;
        if (trans->dir == 'R') cabeca++;
        else if (trans->dir == 'L') cabeca--;

        if (cabeca < 0) cabeca = 0; // não deixa negativo
    }
}

int main(int argc, char *argv[]) {
    if (argc != 4) {
        printf("Uso: %s maquina.json entrada.txt saida.txt\n", argv[0]);
        return 1;
    }

    MaquinaTuring mt;
    char fita[MAX_FITA];

    carregar_maquina(argv[1], &mt);
    carregar_fita(argv[2], fita);

    int aceita = simular(&mt, fita);

    salvar_fita(argv[3], fita);

    printf("%d\n", aceita);
    return 0;
}
